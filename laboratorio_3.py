# -*- coding: utf-8 -*-
"""Laboratorio 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12C7FflUAGFP-MzYfI5wR3O6r0XhOlcFR

# 1. Carga el dataset.
"""

import pandas as pd

# Montar Google Drive si el archivo est√° all√≠
#from google.colab import drive
#drive.mount('/content/drive')

# Cargar el archivo CSV (ajusta la ruta si est√° en tu Drive)
df = pd.read_csv('data/Reviews_reducido.csv')

git commit -m "Subir archivo CSV"
git push origin main


# Ver las primeras filas
df.head()

"""# Seleccionar columnas importantes"""

df = df[['Text', 'Score']]

"""# Crear columna de sentimiento


"""

def sentimiento(score):
    return 'Positivo' if score >= 4 else 'Negativo'

df['Sentimiento'] = df['Score'].apply(sentimiento)

"""# Mostrar distribuci√≥n de sentimientos"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.countplot(x='Sentimiento', data=df)
plt.title("Distribuci√≥n de Sentimientos")
plt.show()

"""# 2. Preguntas r√°pidas para reflexi√≥n:
¬øQu√© tipo de datos encontramos en las columnas?

¬øCu√°l es la proporci√≥n de rese√±as positivas vs. negativas?
"""

df['Sentimiento'].value_counts(normalize=True)

"""# 3. Preprocesamiento y vectorizaci√≥n
üîπ Dividir los datos
"""

from sklearn.model_selection import train_test_split

X = df['Text']
y = df['Sentimiento']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""üîπ Vectorizar el texto"""

from sklearn.feature_extraction.text import CountVectorizer

vectorizer = CountVectorizer()
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

"""# 4. Reflexi√≥n guiada
¬øQu√© hace el CountVectorizer?

CountVectorizer es como una herramienta que convierte las palabras en n√∫meros. Las computadoras no entienden palabras, pero s√≠ entienden n√∫meros. Entonces, CountVectorizer toma todo el texto . y cuenta cu√°ntas veces aparece cada palabra. Luego pone esos n√∫meros en una tabla para que el modelo pueda aprender de ellos. Por ejemplo, si alguien dice ‚Äúexcelente producto‚Äù, CountVectorizer guarda que ‚Äúexcelente‚Äù y ‚Äúproducto‚Äù aparecieron 1 vez.

¬øPor qu√© dividimos los datos en conjuntos de entrenamiento y prueba?

Es como cuando estudias para un examen: primero practicas con ejercicios (entrenamiento) y luego haces una prueba para ver si aprendiste (prueba). Aqu√≠ hacemos lo mismo con el modelo. Usamos una parte de los datos para ense√±arle (entrenamiento) y otra parte diferente para ver si aprendi√≥ bien (prueba). As√≠ evitamos que solo se ‚Äúmemorice‚Äù las respuestas y comprobamos si puede adivinar correctamente con datos nuevos.

# 5. Entrenamiento y evaluaci√≥n del modelo
üîπ Entrenar el modelo
"""

from sklearn.naive_bayes import MultinomialNB

model = MultinomialNB()
model.fit(X_train_vectorized, y_train)

"""üîπ Evaluar el modelo"""

from sklearn.metrics import accuracy_score, classification_report

y_pred = model.predict(X_test_vectorized)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nReporte de clasificaci√≥n:\n", classification_report(y_test, y_pred))

"""üîπ Probar con texto real"""

ejemplos = ["This product is amazing!", "Worst purchase I've ever made."]
ej_vector = vectorizer.transform(ejemplos)
print(model.predict(ej_vector))

"""# Implementaci√≥n detallada"""

# Paso 1: Importar CountVectorizer y modelo Naive Bayes
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB

# Paso 2: Vectorizar el texto
vectorizer = CountVectorizer()
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

# Paso 3: Entrenar modelo Naive Bayes
model = MultinomialNB()
model.fit(X_train_vectorized, y_train)

# Paso 4: Evaluar modelo
from sklearn.metrics import accuracy_score, classification_report

y_pred = model.predict(X_test_vectorized)
print("Precisi√≥n del modelo (accuracy):", accuracy_score(y_test, y_pred))
print("\nReporte de clasificaci√≥n:\n", classification_report(y_test, y_pred))
